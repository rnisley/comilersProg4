/*************************************
 * program5.lpp
 * COSC4785
 * Ric Nisley
 * 10/22/2021
 * 
 * This is the input to flex that generates the scanner. It returns integers.
 * This is based on sample.lpp by kbuckner
 ***********************************/
%{

#include<iostream>
#include<iomanip>
#include<string>
#include"nodes.hpp"
  // this next file is generated by bison
#include"program5.tab.hpp"

using std::string;
using std::endl;
using std::cerr;
using std::cout;

extern string token;
extern string value;
extern int firstColumn;
extern int nextColumn;
extern string id;
extern string prevId;
int error = 0;

/*
 * the noyywrap is how the scanner handles end of file, now it will just
 * quit. 
 * get the line numbers from the scanner because of yylineno
 */

/*
 * trivial yyerror() function. Could  do fancy stuff but for now...
 * BUT YOU MUST SUPPLY ONE!
 */
void yyerror(const char *string)
{
  cerr << string << endl;
  return;
}

%}
%option outfile="program5_lex.cpp"
%option noyywrap
%option yylineno
%x ERROR
%x COMMENT

/*
* DO NOT define 945  different regular expressions. You do NOT need most of
* them. Notice that I put them in as simple rules. Eventually you will need
* to separate ALL those fancy expressions into single simple rules anyway so
* why not start now. 
*/

%%

  /*
   * Whitespace: tab, space, newline.
   */

\n              { //NEWLINE
                  nextColumn = 1;
                  firstColumn = 1;
                  //return NL;
                }

\t              { 
                  firstColumn = nextColumn;
                  nextColumn = nextColumn+(8-(nextColumn-1)%8);
                }

" "             { 
                  firstColumn = nextColumn;
                  nextColumn++;
                }

  /*
   * Comments
   */

\/\/(.*)        {
                  
                }

"/*"            {       
                  BEGIN(COMMENT);
                }

  /*
   * compare_op:
   */
"=="            {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "EQ";
                  return EQ;
                }

">"            {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "GT";
                  return GT;
                }

"<"            {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "LT";
                  return LT;
                }

">="            {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "GEQ";
                  return GE;
                }

"<="            {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "LEQ";
                  return LE;
                }

"!="            {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "NEQ";
                  return NE;
                }

"!"             {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "NOT";
                  return NOT;
                }

"="             {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "ASSIGN";
                  return ASSIGN;
                }

  /*
   * logical_op
   */
"||"            {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "OR";
                  return OR;
                }

"&&"            {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "AND";
                  return AND;
                }

  /*
   * math_op
   */
"+"             {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "PLUS";
                  return PLUS;
                }

"-"             {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "MINUS";
                  return MINUS;
                }

"*"             {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "TIMES";
                  return TIMES;
                }

"/"             {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "DIV";
                  return DIV;
                }

"%"             {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "MOD";
                  return MOD;
                }

"^"             {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "EXP";
                  return 1;
                }

  /*
   * enclosing_op
   */
"{"             {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "LBRACE";
                  return LBRACE;
                }

"}"             {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "RBRACE";
                  return RBRACE;
                }

"["             {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "LBRACK";
                  return LBRACK;
                }

"]"             {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "RBRACK";
                  return RBRACK;
                }

"("             {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "LPAREN";
                  return LPAREN;
                }

")"             {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "RPAREN";
                  return RPAREN;
                }

  /*
   * punctuation
   */
"\."             {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "DOT";
                  return DOT;
                }

","             {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "COMMA";
                  return COMMA;
                }

";"             {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "SEMI";
                  return SEMI;
                }

  /*
   * keyword
   */
"this"          {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "THIS";
                  return THIS;
                }

"if"            {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "IF";
                  return IF;
                }

"else"          {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "ELSE";
                  return ELSE;
                }

"while"         {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "WHILE";
                  return WHILE;
                }

"int"           {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "INT";
                  return INT;
                }

"void"          {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "VOID";
                  return VOID;
                }

"class"         {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "CLASS";
                  return CLASS;
                }

"new"           {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "NEW";
                  return NEW;
                }

"null"         {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "NULLT";
                  return NULLT;
                }

"print"         {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "PRINT";
                  return PRINT;
                }

"read"         {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "READ";
                  return READ;
                }

"return"         {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "RETURN";
                  return RETURN;
                }

  /*
   * Identifier
   */
[_a-zA-Z][_0-9a-zA-Z]*       {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "IDENT";
                  prevId = id;
                  id = yytext;
                  return ID;
                }

  /*
   * Number
   */
[0-9]+      {
                  yylval.ttype=new Node;
                  yylval.ttype->setval(atoi(yytext));
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "NUM";
                  value = yytext;
                  return NUM;
                }

  /* [-][0-9]+      {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  token = "NEG";
                  value = yytext;
                  return NEG;
                }
  */

  /*
   * Matches anything not matched. MUST BE LAST RULE.
   */
.               {
                  BEGIN(ERROR);
                  //error++;
                  //if(error > 20)
                  //{
                  //  yyabort();
                  //}
                  yyless(0);
                }

<COMMENT>\t     { 
                  firstColumn = nextColumn;
                  nextColumn = nextColumn+(8-(nextColumn-1)%8);
                }

<COMMENT>\n     {
                  firstColumn = 1;
                  nextColumn = 1;
                }

<COMMENT>"*/"   {
                  BEGIN(0);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                }

<COMMENT>.      {
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + 1;
                }

<ERROR>\t       { 
                  BEGIN(0);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn+(8-(nextColumn-1)%8);
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                }

<ERROR>"\n"       {
                  BEGIN(0);
                  firstColumn = nextColumn;
                  nextColumn = 1;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                }

<ERROR>" "      {
                  BEGIN(0);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + 2;
                  value = yytext;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                } 
                
<ERROR>"=="            {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                }

<ERROR>">"            {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                }

<ERROR>"<"            {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                }

<ERROR>">="            {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                }

<ERROR>"<="            {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                }

<ERROR>"!="            {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                }

<ERROR>"="            {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                }

<ERROR>"!"            {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                }

<ERROR>"||"            {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                }

<ERROR>"&&"            {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                }

<ERROR>"["      {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + 1;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                } 

<ERROR>"]"      {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + 1;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                } 

<ERROR>"\."      {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + 1;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                } 

<ERROR>","      {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + 1;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                } 

<ERROR>"{"      {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + 1;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                } 

<ERROR>"}"      {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + 1;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                } 

<ERROR>"("      {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + 1;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                } 

<ERROR>")"      {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + 1;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                } 

<ERROR>"+"      {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + 1;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                } 

<ERROR>"-"      {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + 1;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                } 

<ERROR>"/"      {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + 1;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                } 

<ERROR>"*"      {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                }

<ERROR>"%"      {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                }

<ERROR>"^"     {
                  BEGIN(0);
                  yyless(1);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                }


<ERROR>[_a-zA-Z][_0-9a-zA-Z]+      {
                  BEGIN(0);
                  firstColumn = nextColumn;
                  nextColumn = nextColumn + yyleng;
                  if(yyleng > 2)
                  {
                    token = "ER_WD";
                  }
                  else
                  {
                    token = "ER_CH";
                  }
                  value = yytext;
                  cout << token << " type lexical error at "<< yylineno << ":" << firstColumn << ":: " << value << endl;
                } 

<ERROR>.        {
                  yymore();
                }  
%%
